#pragma config(Sensor, in1,    analog1,        sensorAnalog)
#pragma config(Sensor, dgtl5,  bumper,         sensorDigitalIn)
#pragma config(Sensor, dgtl6,  limit,          sensorDigitalIn)
#pragma config(Sensor, dgtl10, digital10,      sensorDigitalOut)
#pragma config(Sensor, dgtl11, digital11,      sensorDigitalOut)
#pragma config(Sensor, dgtl12, digital12,      sensorDigitalOut)
#pragma config(Motor,  port1, rightMotor,      tmotorVex393_HBridge, openLoop, reversed)
#pragma config(Motor,  port10, leftMotor,      tmotorVex393_HBridge, openLoop, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "gotobeacon.c"
#include "arm.c"
#include "escape.c"


task main() {
	bool found_red = false;
	bool pushed_button = false;
	bool found_green = false;

	freq = 0; // 0 = 1 khz (red)
	ambient_level = 200;
	slow_level = 5000;
	stop_level = 6000;
	expose_time = 5;
	steer_sensitivity = 20;
	forward_speed = -100;
	slow_speed = -25;
	spin_speed = -50;
	SensorValue[digital10] = freq;

	// state 1: find red beacon
	while (!found_red) {
		ReadPD();
		Find_max();
		Move();

		if (SensorValue[limit] == 0) {
			motor[port1] = 0;
			motor[port10] = 0;
			found_red = true;
			wait1Msec(1000);
		}
	}

	// state 2: push button
	while (!pushed_button) {
		ReadPD();
		Find_max();
		if (PD_sum > ambient_level) {
			armDown(100);
			wait1Msec(500);
			armUp(100);
			wait1Msec(500);
		}
		else {
			pushed_button = true;
			wait1Msec(1000);
			// move back from red beacon
			motor[port1] = 60;
			motor[port10] = -60;
			wait1Msec(750);
		}
	}

	// state 3: find green
	freq = 1; // 1 = 10 khz (green)
	SensorValue[digital10] = freq;

	while (!found_green) {
		ReadPD();
		Find_max();
		Move();
		if (SensorValue[limit] == 0) {
			motor[port1] = 0;
			motor[port10] = 0;
			found_green = true;
			wait1Msec(1000);
		}
	}

	// state 4: exit arena
	armDown(100);
	wait1Msec(1000);
	escape();
}